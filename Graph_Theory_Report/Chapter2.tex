\chapter{Fundamentals of Graph Theory}

This chapter establishes the mathematical foundations needed to work with graph structures in data science. It introduces formal graph definitions, graph types, matrix representations and key structural concepts such as degree, connectivity and cycles.

\section{Basic Definitions}

\begin{definition}
	A \textbf{graph} is an ordered pair $\graph=(V,E)$ where:
	\[
	V=\{v_1,\ldots,v_n\} \quad \text{and} \quad E \subseteq V \times V.
	\]
\end{definition}

Edges may be \textbf{directed}, \textbf{undirected}, \textbf{weighted} or \textbf{unweighted}.  
Applications like social networks typically use undirected graphs, while recommendation systems or web link structures use directed, weighted graphs \cite{newman2010networks}.

\section{Degree and Neighborhood}

For an undirected graph:
\[
\deg(v) = |\{u \in V : (u,v)\in E\}|.
\]

For a directed graph:
\[
\deg^+(v)=\text{out-degree}, \qquad \deg^-(v)=\text{in-degree}.
\]

\section{Graph Representations}

Graphs can be represented in multiple ways.

\subsection{Adjacency Matrix}

\[
A_{ij} = 
\begin{cases}
	1 & \text{if } (v_i,v_j)\in E,\\
	0 & \text{otherwise.}
\end{cases}
\]

\begin{table}[H]
	\centering
	\caption{Adjacency Matrix of a Simple Graph}
	\begin{tabular}{c|cccc}
		& A & B & C & D \\
		\hline
		A & 0 & 1 & 1 & 0 \\
		B & 1 & 0 & 1 & 1 \\
		C & 1 & 1 & 0 & 1 \\
		D & 0 & 1 & 1 & 0 \\
	\end{tabular}
\end{table}

\subsection{Adjacency List}

For sparse graphs, adjacency lists are far more memory-efficient.

\section{Graph Traversal Algorithms}

Traversal algorithms are essential in data science â€” from exploring social networks to crawling web graphs.

Below are corrected versions of BFS and DFS in proper algorithm floats.

\begin{algorithm}[H]
	\caption{Breadth-First Search (BFS)}
	\begin{algorithmic}[1]
		\Procedure{BFS}{$G, s$}
		\State mark $s$ as visited
		\State enqueue $s$
		\While{queue not empty}
		\State $v \gets$ dequeue()
		\For{each neighbor $u$ of $v$}
		\If{$u$ not visited}
		\State mark $u$
		\State enqueue $u$
		\EndIf
		\EndFor
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Depth-First Search (DFS)}
	\begin{algorithmic}[1]
		\Procedure{DFS}{$G, v$}
		\State mark $v$ as visited
		\For{each neighbor $u$ of $v$}
		\If{$u$ not visited}
		\State DFS($G,u$)
		\EndIf
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\section{Connectivity and Components}

A graph is \textbf{connected} if every pair of vertices is linked by some path.  
Connected components can be identified efficiently with BFS or DFS.

\[
\text{Number of connected components} = k
\]

\section{Cycles and Trees}

A \textbf{tree} is a connected, acyclic graph.  
Fundamental property:
\[
\text{A tree with } n \text{ vertices has } n-1 \text{ edges.}
\]

Trees are widely used in machine learning (e.g., decision trees, hierarchical clustering).